**inttypes头文件**

C++ 11 中inttypes.h 头文件，提供了不同占位的整形

int8_t -- 占一字节整形

int16_t -- 占两字节整形

int32_t -- 占四字节整形（普遍情况）

int64_t -- 占八字节整形



头文件中有一些与整数类型相关的宏定义：

如下：PRI表征这个宏定义，d表示十进制，后面的数字表示整形的位数

PRId8 替换为字符串 ”hhd“

PRId16替换为字符串 “hd”

PRId32替换为字符串 “d”

PRId64替换为字符串 “ld”

这个宏定义也可以实现16进制，只需要将d替换成x，例如PRIx64，也可让16进制大写，例如PRIX64



除此之外inttypes头文件还有一些与整形最大最小值相关的宏定义：

例如，32为整形的最大最小值为

INT32_MAX 

INT32_MIN







**数学运算符**

1. **左值和右值的区分**

   实例：

   ```c
   int a, b = 3, c = 2, d = 3, e = 4;
   
   b = (++c); //此处的++c本质上是左值
   
   a = (++(d + e)); //此处的++(d + e)本质上是右值
   ```

   左值右值如何区分：

   左值：该行代码结束后下一行如果还可以访问到它，那它就是个左值

   右值：该行代码结束后下一行访问不到它了，那它就是个右值，d + e本质上是个临时变量，该行结束后d + e的临时变量被释放，无法访问

   **注意：左值右值并不是靠等号左右区分的**

   c语言中都叫表达式的中间值，c++中会严格区分左值右值

   

2. **运算符的优先级**

   https://baike.baidu.com/item/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/4752611?fr=aladdin

   除了优先级以外，还需要注意运算符的结合方向，相同优先级的两个运算符，执行时取决于它们的结合方向

   例如：

   ```c
   int a = 7;
   
   *p = &a;
   
   *p--; //此处 * 和 -- 运算符相同优先级，两个都是右结合的，那么这行代码会先执行p--，使地址向前移动一位，然后再解引用，a的值并不会被改变
   ```

   

3. **位运算**

   **位运算每一位之间互不影响，只需要思考清楚一位是如何实现的其他位类推就可以**

   异或运算：本质是统计相关位上1的奇偶性，如果1有奇数个，异或结果就是1，如果1有偶数个，异或结果就是0，异或运算是本身的逆运算；

   与运算：理解成相关位进行乘法

   或运算：理解成相关位进行加法

   

   



**程序控制结构**

1. **条件运算符短路原则：**

   条件与&&，如果第一个条件已经为假，后一个条件就不会继续判断了，例如：

   ```c
   int a = 0, b = 0;
   
   if((a++) && (b++)); 
   ```

   此处由于a++会先进行逻辑判断再自增，a = 0已经为假，逻辑与会把后面的条件短路，b++就不会再参与判断了，自然b也就不会自增；

   条件或||，如果第一个条件已经为真，后一个条件也不会继续判断了，例如延续上面的代码：

   ```c
   if((a++) || (b++));
   ```

   上一句与判断结束后a已经发生了自增及该句执行前a = 1，已经为真，所以逻辑或会把后面的条件短路，b也不会自增；

2. **条件运算符使用技巧**

   打印10个数，每个数中间有空格，但最后没有空格

   ```c
   for(int i = 0; i < 10; i ++){
   
   	i == 0 || printf(" "); //利用逻辑或的短路特性，当i不为0，即不是第一个元素时，才开始打印空格
   
   	printf("%d", i); //注意此处数字的输出不要再加空格，这样i为9的时候后面也不会有空格
   
   }
   ```

   求10个随机数中偶数的个数

   ```c
   int cnt = 0;
   
   for(int i = 0; i < 10; i ++){
   
   	int val = rand() % 100;
   
   	cnt += !(val % 2); //当val为偶数时val % 2返回的是0，进行逻辑取反后得到1，即结果加一，否则结果加0
   
   }
   ```

   该奇偶性判断还可以用如下代码实现

   ​	

   ```c
   cnt += !(val & 1); //二进制中最后一位的值决定奇偶性
   ```
   
   ​	val & 1 等价于 val % 2，都是判断奇偶性的方法
   
   ​	val & 3 等价于 val % 4，
   
   ​	val & 7 等价于 val % 8,
   
   即如果要求一个数对2的n次方的余数，就可以转化为位与运算，可答复提高计算效率



